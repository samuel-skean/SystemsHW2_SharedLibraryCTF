0. This one was quite easy. The program prints the secret on its last line of output when run and says its the secret. No need to execute it with any tools.

1. *Run with ltrace (ltrace ./1). Don't input anything yet. *Find the call to rand() within ltrace's output, and see what it returns. The line with the call to rand() will look like "rand(<some arguments>) = <some hex number>" where <some hex number> is the return value of rand(). This value is the secret, but its in hexadecimal, with a leading "0x" to prove it. *Convert that hexadecimal number into decimal. You can do this by hand or by googling the number including the leading 0x followed by "to decimal". *Type the decimal value into the terminal, which is still running "ltrace ./1", and hit enter. ./1 will output the secret. 

2. *Run with strace, with the flag "--follow-forks" (strace --follow-forks ./2). Don't input anything yet. *Each line of strace's output should start with "[pid <some number>]", where <some number> is the PID for the process making that system call. Take the PID output on the latest line of output when the program is waiting for your input, and input that number and hit enter. *The program and strace will output several more lines of code, including "you win! the secret is". Two lines below that, the program outputs the secret. This secret was only numerical digits for me, and it prints directly after the last argument of the system call that prints it, so there is no whitespace between that argument and the secret. For me, that argument was 10, so the secret was everything after the 10 on that line. Just to be safe, the "write" system call on that same line also specifies the secret in as part of its first argument, a string, with no leading digits. The number in that string and the number at the end of that line (ignoring some leading digits) should be the same, and are the secret.

3. *Run with ltrace (ltrace ./3). *Look at the call to __xstat(), a library function that determines the permissions for a filename (it may do other things as well). The string that is the second argument is the name of the file you must create. Run "touch <filename>", where <filename> is that second argument to __xstat(). *Run "chmod a+x <filename>" where <filename> is the same as in the last step. This allows all users to execute the file (though it isn't in the correct format), which ./3 will check for. *Run ./3. The secret is printed on the last line.

4. *Run ./4. Note the name of the "shared object file", also known as a dynamic library, that it reports as missing, which ends in .so. For me this was lib361.so, and I will assume that for future steps. *We need to create that library, but first we need to know what it is expected to do. Run "gdb ./4". Do not exit gdb until told to do so. *In gdb, run the command "disas main". Note that there is a call to a function with a name that starts with "assert_", where the rest of the name signifies some binary operator. *Still in gdb, run "disas assert_*", where * is the end of the function name you just found a call to. Note that it calls a function secretoperation@plt several times. This means it is expecting a function named "secretoperation" to be supplied by some dynamic library (the plt stores code that helps link in dynamically-linked functions, and call them once they have been linked). Because secretoperation is not the name of any known preexisting library function, it is reasonable to assume that it is the function that is expected to be in our library lib361.so. *Still in gdb, continue looking at the output of "disas assert_*". Note that before each call to secretoperation, two constants are moved into the registers %esi and %edi, which are the registers used for the first two parameters of a function call. After each call, the value of %eax is moved to memory and eventually loaded again to be compared with another value, which came from a constant loaded after that call. %eax stores the return value of a function just after it returns. So, the "assert_" function is passing two parameters to secretoperation and expecting certain behavior from it. Recall that the end of the name of the "assert_" function referred to some binary operator. "assert_" is expecting "secretoperation" to perform the bitwise version of this operation on its first two parameters and return the result. You can confirm this by taking the constants moved into the registers %esi and %edi before one of the calls to secretoperation, converting them from hex to binary (either by hand or with google, by googling "<constant including leading 0x> in binary", and performing the bitwise operation specified by after the "assert_" in that function's name. Convert that value back to hex using google or by hand and it should be the same as the constant specified after that call to secretoperation, which is eventually compared to the value from %eax (the return value of secretoperation) for equality. This is true for all sets of three constants in the "assert_" function, but please test at most one. Because %esi, %edi, and %eax all start with e, we know that both parameters and the return value are 4 bytes long, so their type in c will be int. *Now, its time make the library. Exit gdb and create a .c file. I named mine 361.c by convention to match lib361.so, and I will assume that name for these instructions. In 361.c, define a function secretoperation that takes two int parameters and returns the result of the bitwise operation specified in the "assert_" function's name, which is also an int. *Compile 361.c and make it into a shared library with the commands "gcc -c -fPIC 361.c" and "gcc -shared -o lib361.so 361.o", in that order. *Run the command "export LD_LIBRARY_PATH=$(pwd)" to make the dynamic linker look in the current working directory for libraries to load. In this case, it will be looking for lib361.so. *Run ./4, and it should print the secret.

